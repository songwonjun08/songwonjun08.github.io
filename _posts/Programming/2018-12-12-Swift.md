---
layout: page
title: Swift
comments: false
categories: Programming
---

* content
{:toc}

# Swift

개인용도로 Swift 관련 정보, 자료를 정리한 글입니다

---

## 배열 (Array)

````Swift
// 1차원 배열 생성
var names = ["Song","Moon","Bae","Lee"] // 정적 선언
var names : [String] = [] // 동적 선언, 타입 어노테이션 + 초기화 (빈 배열 생성)
````

````swift
// 2차원 배열 생성
var classMember : [[String]] = [[String]]()
````

````swift
// 1차원 배열 추가
names.append("Song") // names[0]
names.append("Moon") // names[1]
names.insert("Frank",at:1) // Frank가 names[1]이 되고 그자리에 있던 Moon 한칸 뒤 names[2]로
names.append(contentsOf:["Yu","Li"]) // 여러 아이템 추가
````

```swift
// 2차원 배열 추가
classMember.append(["Song"]) // classMember[0][0]
classMember.append(["Mike"]) // classMember[1][0]
classMember[0].append("Kim") // classMember[0][1]
classMember[2].append("Ikeda") // Error! 아직 배열[2] 생성 안됨
```

Swift의 클래스는 Call by Reference이다. 따라서 클래스를 append할때 주의가 필요하다.

아래 소스에서 temp2를 만들지 않고 temp를 재활용(값 수정후 다시 append)하려고 하면

배열에 추가(append) 되지 않는다. (같은 주소값을 배열에 연속해서 등록하려고 했기 때문)

````swift
class Human {
    var name = "NONE"
    var age = 0
}

class Database {
    var member : [Human?] = []
    var classMember : [[Human?]] = [[Human?]]()
}

var db = Database()
var member : [[Human?]] = [[Human?]]()

let temp : Human? = Human()
temp?.name = "SONG WONJUN"
temp?.age = 26

db.member.append(temp)
db.classMember.append([temp])

let temp2 : Human? = Human()
temp2?.name = "LEE JAESEOK"
temp2?.age = 30

db.member.append(temp2)
db.classMember.append([temp2])
````



____

## MVC Pattern 

**iOS 앱의 객체 관계는 MVC 패턴에 기반하고 있다.**

![mvc](https://github.com/songwonjun08/songwonjun08.github.io/blob/master/images/mvc.png?raw=true){: width="60%" height="60%"}

- **Model** : 앱의 비즈니스 로직(데이터 입력 수정 조회 등등의 각종 처리업무) 그리고 데이터를 관장하는 영역.

  **View** : 유저에게 보여지는 부분(UI)를 담당하는 영역.

  **Controller** : View와 Model을 이어주는 역할을 함. iOS에서 Controller는 주로 UIViewController의 서브클래스로 선언됨.

- MVC구조 (Model-View-Controller)는 Model과 View를 분리하는것을 통해 범용성과 재사용성을 높여 개발 및 유지 보수를 쉽게 할수있게 한다.

- Controller는 View와 Model과 자유롭게 소통한다. 반대로 View와 Model은 **독립적인 영역**으로써 자신을 제어하는 Controller가 누군지도 모르며 서로 관여해서는 안된다.

![mvc2](https://github.com/songwonjun08/songwonjun08.github.io/blob/master/images/mvc2.jpg?raw=true){: width="60%" height="60%"}

- **Controller에서 View로 접근**

  1. Outlet

     IBOutlet을 통해 Controller는 View에게 너가 보여줄 텍스트, 이미지는 이것이다와 같은 지시를 하게 됨.
     注）XCode에서 보통 스토리보드에서 코드로 드래그하기때문에 View가 Controller에 말을 거는 것 처럼 착각할수가 있으나 실제로는 반대.

     ```swift
     @IBOutlet var txtField1: UITextField!
     @IBOutlet var txtField2: UITextField!
     @IBOutlet var plusButton: UIButton!
     @IBOutlet var resultLabel: UILabel!
     ```

- **View에서 Controller로 접근**

  이용자(User)는 View를 통해서 무언가의 명령을 내릴수도 있다. 때문에 MVC에서 View는 직접 컨트롤러에게 말을 걸어서는 안되지만 제한적으로 2가지 방법을 통해 말을 걸 수 있다.

  1. IBAction

     Controller가 자신에게 과녁(Target)을 설정해놓고 View에게 그 과녁에 쏠 화살(Action)을 건네주는 방법. 대표적으로 IBAction이 있다. 유저가 버튼을 누르면 화살(Action)이 발생(발사)되어 컨트롤러의 메서드(Target)이 작동함. 

     ```swift
     @IBAction func plusButtonClicked(_ sender: Any) {
     }
     ```

  2. Delegation

     Delegation Protocol을 통한 방법.
     프로토콜 활용하여 View 클래스 안에 Controller 인스턴스를 만드는것과 비슷한 개념.
     Delegation은 View가 자신에 대한 제어권을 Controller에게 위임하는 프로토콜.
     예) 뷰의 테이블뷰의 Delegate, Data Source를 컨트롤러에 위임해서 제어권을 넘김. 

     ![mvc3](https://github.com/songwonjun08/songwonjun08.github.io/blob/master/images/mvc3.jpg?raw=true)

- **Controller에서 Model로 접근**

  Controller에 Model 인스턴스를 만들어 주면 된다.  

  ````Swift
  // Model
  class calcModel {
      var value1 : Double = 0.0
      var value2 : Double = 0.0
  }
  ````

  ````swift
  // Controller
  class ViewController: UIViewController {
      let calculator = calcModel() // Create Model Instance
  ````

- **Model에서 Controller로 접근**

  Model은 자신의 데이터가 변할 때와 같이 무엇인가 알려줄 필요가 있을때, 라디오 스테이션 처럼 자신의 주파수에 맞춘 Controller및 Model들에게 관련 안내를 하는 구조로 교신을 하게 된다.  

  이러한 과정은 Observer 행동 패턴의 KVO(Key Value Obse rvation)을 통해 수행되며 변경사항이 있을 경우 통지(Notification)이 가게 된다. (밑의 옵저버 행동 패턴 내용 참고)

----

## Observer 행동 패턴 (Notification)

- Notification은 한 객체가 다른 객체에 자신의 업데이트 상태를 알려주는 방법.

- 어떤 작업이 완료되거나 특정 이벤트가 발생할 경우 다른 객체들에게 알려줄 수 있다.

- MVC구조에서 Modeldl Controller로 접근하기 위해 사용되는 방식.

- 멀티스레딩 Async와 관련하여 뒷단에서 작업을 하는 인스턴스가 자신이 수행한 작업을 완료됬을때 등등 사용





- **옵저버(Observer) 등록**

  NotificationCenter는 Notification은 관장하는 센터이고 .default는 단 하나만 존재해야할 센터에 접근하기 위한 싱글턴 패턴

  뷰컨트롤러에서 **.addObserver** 메소드를 통해 resultNotification에 등록했다.

  어디에선가 resultNotification이 방송 될 경우 resultUpdate라는 함수가 실행된다.

  name : .UIKeyboardWillShow 또는 UIApplicationDidEnterBackground 등 애플에서 만들어놓은 Notification도 존재한다.

````swift
// ViewController.swift
override func viewDidLoad() {
   super.viewDidLoad()
   NotificationCenter.default.addObserver(self,
              selector: #selector(resultUpdate),
              name: NSNotification.Name(rawValue: "resultNotification"),
              object: nil)
    }
    
    @objc func resultUpdate() {
        resultLabel.text = String(calculator.result)
    }
````





- **노티피케이션(Notification) 만들기**

  MVC패턴의 Model부분에서 **.post** 메소드를 통해 Notification을 만들어 주었다.

  sum()함수가 실행될 경우 resultNotification이라는 이름의 노티피케이션이 방송된다.

````swift
// calc.swift
import Foundation

class calcModel {
    var value1 : Double = 0.0
    var value2 : Double = 0.0
    var result : Double = 0.0
    
    func sum() {
        result = value1 + value2
        
        NotificationCenter.default.post(
            name: NSNotification.Name(rawValue: "resultNotification"),
            object: nil)
    }
}

````

 



MVC패턴 예제를 만들었다. [링크](https://github.com/songwonjun08/SwiftMVCExample)

textField 두개에 숫자가 입력되고 Button을 누르면 calcModel 클래스 인스턴스에 값이 들어가고 sum함수를 실행한다. sum 함수는 두 값을 더해 result에 저장한후 resultNotification을 방송. 그 방송을 감지한 뷰 컨트롤러는 함수 resultUpdate()를 실행한다.

````swift
// ViewController.swift
@IBAction func plusButtonClicked(_ sender: Any) {
        if let val1 = Double((txtField1?.text)!) {
            if let val2 = Double((txtField2?.text)!) {
                calculator.value1 = val1
                calculator.value2 = val2
                calculator.sum()
            }
        }
    }
````

___

##Observer 행동 패턴 (KVO)

- KVO

  Key-Value Observing(KVO) 패턴은 어떤 프로퍼티가 업데이트 되었을때 이를 알려주는 역할을 함
  자신의 프로퍼티 뿐만아니라 남의 프로퍼티가 업데이트 될때도 알림 받을수 있음.

````swift
// Wallet.swift
import Foundation
class Wallet : NSObject {
    // dynamic : Swift런타임이 아닌 Objective-C런타임을 쓰겠다.
    @objc dynamic var money: Int = 0
}
````

````swift
// ViewController.swift
import UIKit

class ViewController: UIViewController {

    var wallet: Wallet = Wallet()
    
    @IBOutlet var label: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // money를 감시대상으로 정한다.
        wallet.addObserver(self,forKeyPath: "money", options: [.old, .new], context: nil)
        
        wallet.money = 2000
        label.text = String(wallet.money)
    }

    @IBAction func buttonClicked(_ sender: Any) {
        wallet.money-=300
        label.text = String(wallet.money)
    }
    
    deinit {
        wallet.removeObserver(self, forKeyPath: "money")
    }
    
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if(wallet.money < 1000) {
            print("잔고가 1000원 미만입니다!")
        }
    }
}
````



![kvo](https://github.com/songwonjun08/songwonjun08.github.io/blob/master/images/kvo.jpg?raw=true)





